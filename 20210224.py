# 毫無價值的代碼
# 再次強調，本代碼純屬娛樂，請大家不要學習
# 5.033167

import datetime
import numpy
import pandas


def 取得段(日期):
	月日 = 日期[5:]
	if 月日 < "03-01":
		return 0
	if 月日 < "05-01":
		return 1
	if 月日 < "08-01":
		return 2
	return 3


def 處理原表(某原表):
	某表 = None
	for 甲 in range(24):
		甲表 = 某原表.loc[:, ["日期", "日序", "站點", "段", "H%d" % 甲]].rename({"H%d" % 甲: "壓力"}, axis=1)
		甲表["時"] = 甲
		某表 = pandas.concat([某表, 甲表], ignore_index=True)
	
	return 某表


零日 = datetime.datetime.strptime("2021-01-01", "%Y-%m-%d")
近期原表 = pandas.read_csv("test_水压数据_2020.csv")
近期原表.columns = ["日期", "站點"] + 近期原表.columns[2:].to_list()
近期原表["日序"] = [(datetime.datetime.strptime(子, "%Y-%m-%d") - 零日).days for 子 in 近期原表.日期]
近期原表["段"] = [取得段(子) for 子 in 近期原表.日期]
近期表 = 處理原表(近期原表)
近期表 = 近期表.loc[(近期表.壓力 >= 0.1) & (近期表.壓力 <= 0.5)]

歷史測試零日 = datetime.datetime.strptime("2020-01-01", "%Y-%m-%d")
歷史原表 = pandas.read_csv("train_水压数据_2019.csv", header=0)
歷史原表.columns = ["日期", "站點"] + 歷史原表.columns[2:].to_list()
歷史原表["日序"] = [(datetime.datetime.strptime(子, "%Y-%m-%d") - 歷史測試零日).days for 子 in 歷史原表.日期]
歷史原表["段"] = [取得段(子) for 子 in 歷史原表.日期]
歷史表 = 處理原表(歷史原表)
歷史表 = 歷史表.loc[(歷史表.壓力 >= 0.1) & (歷史表.壓力 <= 0.5)]

待測表 = pandas.read_csv("to_predict.csv")
待測表.columns = ["標識", "日期", "站點", "時"]
待測表["時"] = [int(子[1:]) for 子 in 待測表.時]
待測表["日序"] = [(datetime.datetime.strptime(子, "%Y-%m-%d") - 零日).days for 子 in 待測表.日期]
待測表["段"] = [取得段(子) for 子 in 待測表.日期]
待測表["月日"] = [子[5:] for 子 in 待測表.日期]

# 以下分別利用歷史同期數據和近期數據預測
歷史預測表 = 待測表.loc[:, ["站點", "日序", "時"]].merge(歷史表.loc[:, ["站點", "日序", "時", "壓力"]].rename({"日序": "訓練日序", "壓力": "訓練壓力"}, axis=1), on=["站點", "時"])
歷史預測表 = 歷史預測表.loc[(歷史預測表.日序 - 歷史預測表.訓練日序).abs() <= 3]
歷史預測表["權重"] = 1 / (1 + (歷史預測表.日序 - 歷史預測表.訓練日序).abs() ** 4)
歷史預測表["加權訓練壓力"] = 歷史預測表.權重 * 歷史預測表.訓練壓力
歷史預測表 = 歷史預測表.groupby(["站點", "日序", "時"]).aggregate({"權重": "sum", "加權訓練壓力": "sum"}).reset_index()
歷史預測表["歷史預測壓力"] = 歷史預測表.加權訓練壓力 / 歷史預測表.權重
歷史預測表 = 歷史預測表.loc[:, ["站點", "日序", "時", "歷史預測壓力"]]

預測表 = 待測表.loc[:, ["標識", "站點", "段", "月日", "日序", "時"]].merge(近期表.loc[(近期表.壓力 >= 0.1) & (近期表.壓力 <= 0.5), ["站點", "段", "日序", "時", "壓力"]].rename({"日序": "訓練日序", "壓力": "訓練壓力"}, axis=1), on=["站點", "段", "時"])
預測表["權重"] = 1 / (預測表.日序 - 預測表.訓練日序) ** 2
預測表["加權訓練壓力"] = 預測表.權重 * 預測表.訓練壓力
預測表 = 預測表.groupby(["標識", "站點", "段", "日序", "時"]).aggregate({"權重": "sum", "加權訓練壓力": "sum"}).reset_index()
預測表["近期預測壓力"] = 預測表.加權訓練壓力 / 預測表.權重
預測表 = 預測表.merge(歷史預測表, on=["站點", "日序", "時"], how="left")
預測表.loc[預測表.歷史預測壓力.isna(), "歷史預測壓力"] = 預測表.loc[預測表.歷史預測壓力.isna(), "近期預測壓力"]

# 將歷史同期預測和近期預測進行加權集成
# 其中前兩段直接用近期預測而不需要集成，後兩段加以9:1的權重集成
# 我完全可以給出能讓大家滿意的解釋來說明我是如何做出這一判斷的，但事實上我衹是經過測試發現這樣比較好
# 如果換一個年份，完全有可能是前兩段要加以9:1的權重集成，而後兩段不要集成
預測表["近期係數"] = 1.0
預測表.loc[預測表.段.isin([2, 3]), "近期係數"] = 0.9
預測表["預測壓力"] = 預測表.近期係數 * 預測表.近期預測壓力 + (1 - 預測表.近期係數) * 預測表.歷史預測壓力

# 乘以一個係數，以固定預測的總平均值
# 同樣我可以做一些令人眼花繚亂的計算來得到0.2805這個數值，但事實上它衹是我之前的最佳結果的總平均值，我不能保證它是最好的，也許換成0.2800或者0.2810會得到更高的成績
預測表.預測壓力 *= 0.2805 / 預測表.預測壓力.mean()
預測表 = 預測表.loc[:, ["標識", "站點", "日序", "時", "預測壓力"]]

提交表 = 預測表.loc[:, ["標識", "預測壓力"]]
提交表.columns = ["id", "pressure"]
提交表.to_csv("20210224.csv", header=True, index=False)
